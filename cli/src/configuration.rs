use std::{
    fs::File,
    io::{BufRead, BufReader, Read, Write},
    path::{Path, PathBuf},
    process::Stdio,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
    time::Duration,
};

use clap::ArgMatches;
use directories::UserDirs;
use indicatif::{MultiProgress, ProgressBar, ProgressStyle};

use crate::{
    Network, APP_DIR_NAME, AUTOGENERATED, PLUGIN_BYTES, PLUGIN_NAME, TEMP_APP_DIR, TEMP_PLUGIN_PATH,
};

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]
pub struct GeyserConfig {
    pub(crate) network: Network,
    pub(crate) account: Option<String>,
    pub(crate) extras_location: Option<PathBuf>,
    pub(crate) extra: Vec<String>,
    pub(crate) dir: PathBuf,
    pub(crate) plugin: PathBuf,
}

impl GeyserConfig {
    pub fn new(user_args: ArgMatches) -> Self {
        let mut config: GeyserConfig = user_args.try_into().unwrap();

        if config.dir.as_path() == Path::new(TEMP_APP_DIR) {
            if let Some(user_dirs) = UserDirs::new() {
                let mut home_dir = user_dirs.home_dir().to_path_buf();
                home_dir.push(APP_DIR_NAME);
                config.dir = home_dir;
            } else {
                eprintln!("WARNING: Falling Back temporary directory ({TEMP_APP_DIR}) since the home directory was not detected and you didn't provide a custom directory",)
                //FIXME: SWITCH to using log
            }
        }

        let mut plugin = config.dir.clone();
        plugin.push(PLUGIN_NAME);
        config.plugin = plugin;

        config.read_extra_conf();

        config
    }

    fn read_extra_conf(&mut self) -> &mut Self {
        if let Some(extras_location) = self.extras_location.as_ref() {
            let mut file = File::open(extras_location).unwrap();
            let mut contents = String::new();
            file.read_to_string(&mut contents).unwrap();

            let parsed = toml::from_str::<Vec<String>>(&contents).unwrap();

            parsed
                .into_iter()
                .for_each(|account| self.extra.push(account));
        }

        self
    }

    pub fn to_json5(&self) -> jzon::JsonValue {
        let accounts = if self.extra.is_empty() {
            &["*".to_string()]
        } else {
            self.extra.as_slice()
        };

        jzon::object! {
            libpath: self.plugin.to_string_lossy().to_string(),
            accounts_selector: {
                accounts: accounts
            }
        }
    }

    pub fn init(self) -> Self {
        if let Some(error) = std::fs::DirBuilder::new().create(&self.dir).err() {
            if error.kind() == std::io::ErrorKind::AlreadyExists {
                eprintln!("APP DIR ALREADY INITIALIZED"); //FIXME Switch to log
            } else {
                eprintln!("ERROR WHILE CREATING APP DIR: {:?}", error.to_string());
                std::process::exit(1);
            }
        }

        // if !self.plugin.exists() {
        //     let mut file = std::fs::OpenOptions::new()
        //         .write(true)
        //         .create(true)
        //         .open(&self.plugin)
        //         .unwrap();

        //     file.write_all(&PLUGIN_BYTES).unwrap();
        // } //TODO Decide if to overwrite plugin whenever app is started

        let mut file = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(&self.plugin)
            .unwrap();

        file.write_all(PLUGIN_BYTES).unwrap();

        let config_file_output = self.to_json5().to_string();
        let mut config_file_output_file = self.dir.clone();
        config_file_output_file.push(AUTOGENERATED);

        let mut file = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .open(config_file_output_file)
            .unwrap();

        file.write_all(config_file_output.as_bytes()).unwrap();

        self
    }

    pub fn start_validator(self) {
        let running = Arc::new(AtomicUsize::new(0));
        let r = running.clone();
        ctrlc::set_handler(move || {
            let prev = r.fetch_add(1, Ordering::SeqCst);
            if prev == 0 {
                println!("Exiting...");
            } else {
                std::process::exit(0);
            }
        })
        .expect("Error setting Ctrl-C handler");

        let mut ledger_dir = self.dir.clone();
        ledger_dir.push("ledger");

        let mut command = std::process::Command::new("solana-test-validator")
            .arg("--geyser-plugin-config")
            .arg(self.autogenerated())
            .arg("--ledger")
            .arg(&ledger_dir)
            .stdout(Stdio::piped())
            .spawn()
            .unwrap();

        let child_stdout = command.stdout.as_mut().unwrap();
        let stdout_reader = BufReader::new(child_stdout);
        let stdout_lines = stdout_reader.lines();

        let pb_style = ProgressStyle::with_template("{spinner} {msg}")
            .unwrap()
            .tick_strings(&["⊶", "⊷", "↯"]);

        let multiple_pb = MultiProgress::new();

        let status_pb = multiple_pb.add(ProgressBar::new_spinner());
        status_pb.enable_steady_tick(Duration::from_millis(120));
        status_pb.set_style(pb_style.clone());
        status_pb.set_message("Plugin Up and Running");

        let validator_pb = multiple_pb.add(ProgressBar::new_spinner());
        validator_pb.enable_steady_tick(Duration::from_millis(120));
        validator_pb.set_style(pb_style);

        for line in stdout_lines {
            validator_pb.set_message(line.unwrap());

            if running.load(Ordering::SeqCst) > 0 {
                return;
            }
        }

        validator_pb.finish_with_message("Received Ctrl+C. Terminating Validator...");
        status_pb.finish_with_message("Received Ctrl+C. Terminating Application Exiting...");

        let exist_status = command.wait().unwrap().code().map_or(1, |code| code);
        std::process::exit(exist_status);
    }

    fn autogenerated(&self) -> PathBuf {
        let mut autogenerated = PathBuf::new();
        autogenerated.push(&self.dir);
        autogenerated.push(AUTOGENERATED);

        autogenerated
    }
}

impl Default for GeyserConfig {
    fn default() -> Self {
        Self {
            network: Network::default(),
            account: Option::default(),
            extras_location: Option::default(),
            extra: Vec::default(),
            dir: Path::new(TEMP_APP_DIR).into(),
            plugin: Path::new(TEMP_PLUGIN_PATH).into(),
        }
    }
}
